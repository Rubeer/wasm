<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
</head>

<style> body{ margin: 0; overflow: hidden; font-family: monospace;} </style>
<canvas id="canvas_webgl"> </canvas>

<script>
    const MemoryPageCount = 1024;
    const MemorySize = MemoryPageCount * 65536;
    let Imports = {};
    Imports.memory = new WebAssembly.Memory({initial:MemoryPageCount});
    const Memory = new Uint8Array(Imports.memory.buffer);
    let gl = null;
    let GLObjects = new Array();
    const ASCIIDecoder = new TextDecoder("ascii");

    let FontAtlasPixels = null;
    let FontAtlasGeom = null;

    async function LoadImageAsRawPixels(FileName)
    {
        let Img = new Image();
        Img.src = FileName;
        await Img.decode();

        let DummyCanvas = document.createElement("canvas");
        let Context = DummyCanvas.getContext("2d");
        Context.drawImage(Img, 0, 0);

        let Data = Context.getImageData(0, 0, Img.width, Img.height).data;

        DummyCanvas.remove();
        return Data;
    }


    function GetWasmString(Length, Pointer)
    {
        const Data = Memory.subarray(Pointer, Pointer+Length);
        return ASCIIDecoder.decode(Data);
    }

    function PushGLObj(Obj)
    {
        GLObjects.push(Obj);
        return GLObjects.length - 1;
    }


    Imports.JS_Log = function(MsgLength, MsgPtr)
    {
        console.log("main.wasm: " + GetWasmString(MsgLength, MsgPtr));
    }

    Imports.JS_Abort = function(ReasonLength, ReasonPtr,
                                FileNameLength, FileNamePtr,
                                FuncNameLength, FuncNamePtr,
                                LineNumber)
    {
        const Reason = GetWasmString(ReasonLength, ReasonPtr);
        const FileName = GetWasmString(FileNameLength, FileNamePtr);
        const FuncName = GetWasmString(FuncNameLength, FuncNamePtr);
        const Message = "ABORT: in function: " + FuncName + " (" + FileName + ":" + LineNumber + "): " + Reason;
        document.body.innerHTML = "<pre>" + Message + "</pre>";
        throw new Error(Message);
    }

    
    Imports.glClear = function(Mask) { gl.clear(Mask); }
    Imports.glClearColor = function(R, G, B, A) { gl.clearColor(R, G, B, A); }
    Imports.glCreateShader = function(Type) { return PushGLObj(gl.createShader(Type)); }
    Imports.glCreateProgram = function() { return PushGLObj(gl.createProgram()); }
    Imports.glAttachShader = function(Program, Shader) { gl.attachShader(GLObjects[Program], GLObjects[Shader]); }
    Imports.glLinkProgram = function(Program) { gl.linkProgram(Prog); }
    Imports.glUseProgram = function(Program) { gl.useProgram(GLObjects[Program]); }
    Imports.glCreateVertexArray = function(Program) {return PushGLObj(gl.createVertexArray()) };
    Imports.glCreateBuffer = function(Program) {return PushGLObj(gl.createBuffer()) };
    Imports.glBindBuffer = function(Type, Buffer) { gl.bindBuffer(Type, GLObjects[Buffer]); }
    Imports.glBindVertexArray = function(Arr) { gl.bindVertexArray(GLObjects[Arr]); }
    Imports.glEnableVertexAttribArray = function(Index) { gl.enableVertexAttribArray(Index) };
    Imports.glDrawArrays = function(Mode, First, Count) { gl.drawArrays(Mode, First, Count); }
    Imports.glDrawElements = function(Mode, Count, Type, Offset) { gl.drawElements(Mode, Count, Type, Offset); }
    Imports.glEnable = function(Mode) { gl.enable(Mode); }
    Imports.glDisable = function(Mode) { gl.disable(Mode); }

    Imports.glGetUniformLocation = function(Program, NameLen, NamePtr)
    {
        return PushGLObj(gl.getUniformLocation(GLObjects[Program], GetWasmString(NameLen, NamePtr)));
    }

    Imports.glUniformMatrix4fv = function(Loc, Transpose, DataPtr)
    {
        const Data = new Float32Array(Memory.buffer, DataPtr, 16);
        gl.uniformMatrix4fv(GLObjects[Loc], Transpose, Data);
    }

    Imports.glGetAttribLocation = function(Program, NameLength, NamePtr)
    {
        return gl.getAttribLocation(GLObjects[Program], GetWasmString(NameLength, NamePtr)); 
    }

    Imports.glVertexAttribPointer = function(Index, Size, Type, Normalized, Stride, Offset) 
    {
        gl.vertexAttribPointer(Index, Size, Type, Normalized, Stride, Offset);
    }

    Imports.glShaderSource = function(ShaderID, SourceLen, SourcePtr)
    {
        return gl.shaderSource(GLObjects[ShaderID], GetWasmString(SourceLen, SourcePtr));
    }

    Imports.glCompileShader = function(ShaderIndex)
    {
        const Shader = GLObjects[ShaderIndex];
        gl.compileShader(Shader);
        if(!gl.getShaderParameter(Shader, gl.COMPILE_STATUS))
        {
            throw new Error(gl.getShaderInfoLog(Shader));
        }
    }


    Imports.glBufferData = function(Target, Size, DataPtr, UsageHint)
    {
        if(DataPtr != 0)
        {
            const Data = Memory.subarray(DataPtr, DataPtr+Size);
            gl.bufferData(Target, Data, UsageHint); // Allocate&upload to GPU
        }
        else
        {
            gl.bufferData(Target, Size, UsageHint); // Only allocate
        }
    }

    Imports.glBufferSubData = function(Target, Offset, Size, DataPtr)
    {
        const Data = Memory.subarray(DataPtr, DataPtr+Size);
        gl.bufferSubData(Target, Offset, Data);
    }

    function CompileShader(Type, SourceLen, SourcePtr)
    {
        const Shader = gl.createShader(Type);
        const Source = GetWasmString(SourceLen, SourcePtr);
        gl.shaderSource(Shader, Source);
        gl.compileShader(Shader);
        if(!gl.getShaderParameter(Shader, gl.COMPILE_STATUS))
        {
            const Message = gl.getShaderInfoLog(Shader);
            document.body.innerHTML = "<b><pre>" + Message + "</pre></b><pre>" + "\n\n" + Source + "</pre>";
            throw new Error(Message);
        }
        return Shader;
    }

    Imports.JS_GL_CreateCompileAndLinkProgram = function(VertLen, VertPtr, FragLen, FragPtr)
    {
        const Vert = CompileShader(gl.VERTEX_SHADER, VertLen, VertPtr);
        const Frag = CompileShader(gl.FRAGMENT_SHADER, FragLen, FragPtr);
        const Program = gl.createProgram();
        gl.attachShader(Program, Vert);
        gl.attachShader(Program, Frag);
        gl.linkProgram(Program);
        gl.deleteShader(Vert);
        gl.deleteShader(Frag);
        if(!gl.getProgramParameter(Program, gl.LINK_STATUS))
        {
            const Message = "WebGL link error: " + gl.getProgramInfoLog(Program);
            document.body.innerHTML = Message;
            throw new Error(Message);
        }

        return PushGLObj(Program);
    }


    async function Init()
    {
        FontAtlasPixels = LoadImageAsRawPixels("font_atlas_signed_distance_field.png");
        FontAtlasGeom = await fetch("font_atlas_signed_distance_field.geom");
        FontAtlasGeom = await FontAtlasGeom.arrayBuffer();
        FontAtlasPixels = await FontAtlasPixels;

        const Program = await WebAssembly.instantiateStreaming(
            fetch("main.wasm"),
            {"env":Imports}
        );

        console.log(Program.instance.exports);
        const Functions = Program.instance.exports;


        var Canvas = document.getElementById("canvas_webgl");

        function Resize()
        {
            const Ratio = window.devicePixelRatio;
            const Width = window.innerWidth;
            const Height = window.innerHeight;
            Canvas.width = Width;
            Canvas.height = Height;
            gl.viewport(0, 0, Width, Height);
            console.log("Resize");

        }
        window.addEventListener('resize', Resize);

        Canvas.addEventListener("mousemove", Event =>
        {
            const Rect = Canvas.getBoundingClientRect();
            const MouseX = Event.clientX - Rect.left;
            const MouseY = Event.clientY - Rect.top;
            Functions.MouseMove(MouseX, MouseY);
        });

        Canvas.addEventListener("mousedown", Event =>
        {
            Functions.MouseLeft(true);
        });

        Canvas.addEventListener("mouseup", Event =>
        {
            Functions.MouseLeft(false);
        });

        window.addEventListener("keydown", Event =>
        {
            Functions.KeyPress(Event.keyCode, true);
        });

        window.addEventListener("keyup", Event =>
        {
            Functions.KeyPress(Event.keyCode, false);
        });

        gl = Canvas.getContext("webgl2");
        if(!gl)
        {
            var Message = "WebGL 2 context could not be acquired";
            document.body.innerHTML = Message;
            throw Error(Message);
        }


        Functions.InitOpenGL();

        var Prev = null;
        function RenderLoop(Now)
        {
            var DeltaTime = Prev ? Now - Prev : Now;
            Prev = Now;

            window.requestAnimationFrame(RenderLoop);
            gl.clearColor(0.3, 0.3, 0.3, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);
            var Rect = gl.canvas.getBoundingClientRect();

            Functions.UpdateAndRender(gl.canvas.width, gl.canvas.height, DeltaTime*0.001);
        }

        Resize();
        window.requestAnimationFrame(RenderLoop);
    }

    Init();


</script>

</html>
