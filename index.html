<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
</head>

<style> body{ margin: 0; overflow: hidden; } </style>
<canvas id="canvas_webgl"> </canvas>


<script type="vertex_shader" id="VertexShader">
    #version 300 es
    
    layout (location=0) in vec4 Position;
    layout (location=1) in vec3 Color;
    
    out vec3 VertColor;

    void main()
    {
        VertColor = Color;
        gl_Position = Position;
    }
</script>

<script type="fragment_shader" id="FragmentShader">

    #version 300 es
    precision highp float;
    
    in vec3 VertColor;
    out vec4 FragColor;

    void main()
    {
        FragColor = vec4(vColor, 1.0);
    }

</script>

<script>
    // NOTE(robin): Globals
    const MemoryPageCount = 1024;
    const MemorySize = MemoryPageCount * 65536;
    let Imports = {};
    Imports.memory = new WebAssembly.Memory({initial:MemoryPageCount});
    const Memory = new Uint8Array(Imports.memory.buffer);
    var gl = null;
    var GLObjects = new Array();
    
    const ASCIIDecoder = new TextDecoder("ascii");
    function GetWasmString(Length, Pointer)
    {
        const Data = Memory.subarray(Pointer, Pointer+Length);
        return ASCIIDecoder.decode(Data);
    }

    function PushGLObj(Obj)
    {
        GLObjects.push(Obj);
        return GLObjects.length - 1;
    }


    Imports.JS_Log = function(MsgLength, MsgPtr)
    {
        console.log("main.wasm: " + GetWasmString(MsgLength, MsgPtr));
    }

    Imports.JS_Abort = function(ReasonLength, ReasonPtr,
                               FileNameLength, FileNamePtr,
                               LineNumber)
    {
        const Reason = GetWasmString(ReasonLength, ReasonPtr);
        const FileName = GetWasmString(FileNameLength, FileNamePtr);
        const Message = "main.wasm: ABORT: (" + FileName + ":" + LineNumber + ") " + Reason;
        throw new Error(Message);
    }

    
    Imports.glClear = function(Mask) { gl.clear(Mask); }
    Imports.glClearColor = function(R, G, B, A) { gl.clearColor(R, G, B, A); }
    Imports.glCreateShader = function(Type) { return PushGLObj(gl.createShader(Type)); }
    Imports.glCreateProgram = function() { return PushGLObj(gl.createProgram()); }
    Imports.glAttachShader = function(Program, Shader) { gl.attachShader(GLObjects[Program], GLObjects[Shader]); }
    Imports.glLinkProgram = function(Program) { gl.linkProgram(Prog); }
    Imports.glUseProgram = function(Program) { gl.useProgram(GLObjects[Program]); }
    Imports.glCreateVertexArray = function(Program) {return PushGLObj(gl.createVertexArray()) };
    Imports.glCreateBuffer = function(Program) {return PushGLObj(gl.createBuffer()) };
    Imports.glBindBuffer = function(Type, Buffer) { gl.bindBuffer(Type, GLObjects[Buffer]); }
    Imports.glBindVertexArray = function(Arr) { gl.bindVertexArray(GLObjects[Arr]); }
    Imports.glEnableVertexAttribArray = function(Index) { gl.enableVertexAttribArray(Index) };
    Imports.glDrawArrays = function(DrawMode, First, Count) { gl.drawArrays(DrawMode, First, Count); }
    Imports.glEnable = function(Mode) { gl.enable(Mode); }
    Imports.glDisable = function(Mode) { gl.disable(Mode); }

    Imports.glGetUniformLocation = function(Program, NameLen, NamePtr)
    {
        return PushGLObj(gl.getUniformLocation(GLObjects[Program], GetWasmString(NameLen, NamePtr)));
    }

    Imports.glUniformMatrix4fv = function(Loc, Transpose, DataPtr)
    {
        const Data = new Float32Array(Memory.buffer, DataPtr, 16);
        gl.uniformMatrix4fv(GLObjects[Loc], Transpose, Data);
    }

    Imports.glGetAttribLocation = function(Program, NameLength, NamePtr)
    {
        return gl.getAttribLocation(GLObjects[Program], GetWasmString(NameLength, NamePtr)); 
    }

    Imports.glVertexAttribPointer = function(Index, Size, Type, Normalized, Stride, Offset) 
    {
        gl.vertexAttribPointer(Index, Size, Type, Normalized, Stride, Offset);
    }

    Imports.glShaderSource = function(ShaderID, SourceLen, SourcePtr)
    {
        return gl.shaderSource(GLObjects[ShaderID], GetWasmString(SourceLen, SourcePtr));
    }

    Imports.glCompileShader = function(ShaderIndex)
    {
        const Shader = GLObjects[ShaderIndex];
        gl.compileShader(Shader);
        if(!gl.getShaderParameter(Shader, gl.COMPILE_STATUS))
        {
            throw new Error(gl.getShaderInfoLog(Shader));
        }
    }


    Imports.glBufferData = function(Type, Size, DataPtr, UsageHint)
    {
        const Data = Memory.subarray(DataPtr, DataPtr+Size);
        gl.bufferData(Type, Data, UsageHint);
    }

    function CompileShader(Type, SourceLen, SourcePtr)
    {
        const Shader = gl.createShader(Type);
        gl.shaderSource(Shader, GetWasmString(SourceLen, SourcePtr));
        gl.compileShader(Shader);
        if(!gl.getShaderParameter(Shader, gl.COMPILE_STATUS))
        {
            throw new Error(gl.getShaderInfoLog(Shader));
        }
        return Shader;
    }

    Imports.JS_GL_CreateCompileAndLinkProgram = function(VertLen, VertPtr, FragLen, FragPtr)
    {
        const Vert = CompileShader(gl.VERTEX_SHADER, VertLen, VertPtr);
        const Frag = CompileShader(gl.FRAGMENT_SHADER, FragLen, FragPtr);
        const Program = gl.createProgram();
        gl.attachShader(Program, Vert);
        gl.attachShader(Program, Frag);
        gl.linkProgram(Program);
        gl.deleteShader(Vert);
        gl.deleteShader(Frag);
        if(!gl.getProgramParameter(Program, gl.LINK_STATUS))
        {
            throw new Error(gl.getProgramInfoLog(Program));
        }

        return PushGLObj(Program);
    }


    async function Init()
    {
        const Program = await WebAssembly.instantiateStreaming(
            fetch("main.wasm"),
            {"env":Imports}
        );

        const Functions = Program.instance.exports;


        var Canvas = document.getElementById("canvas_webgl");

        function Resize()
        {
            const Ratio = window.devicePixelRatio;
            const Width = window.innerWidth;
            const Height = window.innerHeight;
            Canvas.width = Width;
            Canvas.height = Height;
            gl.canvas.width = Width*Ratio;
            gl.canvas.height = Height*Ratio;
            gl.viewport(0, 0, Width, Height);
            console.log("Resize");

        }
        window.addEventListener('resize', Resize);

        gl = Canvas.getContext("webgl2");
        if(!gl)
        {
            var Message = "WebGL 2 context could not be acquired";
            document.body.innerHTML = Message;
            throw Error(Message);
        }

        Functions.InitOpenGL();

        function RenderLoop()
        {
            window.requestAnimationFrame(RenderLoop);

            gl.clearColor(0.3, 0.3, 0.3, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);
            Functions.UpdateAndRender(gl.canvas.width, gl.canvas.height, 0.0);
        }

        Resize();
        RenderLoop();
    }

    Init();


</script>

</html>
